<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Pac-Man: City Icons Edition</title>
  <style>
    :root {
      --bg: #0b0f19;
      --wall: #1f2a44;
      --pellet: #ffd166;
      --power: #ff7b7b;
      --pacman: #ffe600;
      --ghost1: #ef476f;
      --ghost2: #06d6a0;
      --ghost3: #118ab2;
      --ghost4: #8338ec;
      --goal: #eaeaea;
      --ui: #c6d0f5;
      --accent: #80ffdb;
    }
    html, body {
      margin: 0;
      height: 100%;
      background: radial-gradient(1000px 800px at 60% -10%, #18233a 0%, var(--bg) 50%, #06080f 100%);
      color: var(--ui);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
      overflow: hidden;
    }
    .wrap {
      display: grid;
      grid-template-rows: auto 1fr auto;
      height: 100%;
      place-items: center;
      gap: .25rem;
    }
    header {
      text-align: center;
      padding: .25rem .5rem;
    }
    h1 {
      margin: .2rem 0 .1rem;
      font-size: clamp(18px, 2.8vw, 28px);
      letter-spacing: .5px;
    }
    .subtitle { opacity: .8; font-size: .95rem; }
    canvas {
      image-rendering: pixelated;
      background: rgba(4,8,16,.5);
      border-radius: 10px;
      box-shadow: 0 0 0 2px rgba(255,255,255,.06), 0 10px 30px rgba(0,0,0,.5), inset 0 0 60px rgba(0,0,0,.4);
      touch-action: none;
    }
    .hud {
      display: flex;
      gap: 1rem;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
    }
    .btn {
      background: transparent;
      color: var(--accent);
      border: 1px solid rgba(255,255,255,.2);
      padding: .45rem .75rem;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
    }
    .btn:hover { background: rgba(255,255,255,.06); }
    .score, .status { min-width: 110px; text-align:center; }
    .mobile-controls {
      display: grid;
      grid-template-columns: 70px 70px 70px;
      grid-template-rows: 70px 70px 70px;
      gap: 6px;
      margin: .4rem 0 .6rem;
      user-select: none;
    }
    .pad {
      display: none;
      align-items: center;
      justify-content: center;
    }
    .pad button {
      width: 70px; height: 70px; border-radius: 12px;
      border: 1px solid rgba(255,255,255,.25);
      background: rgba(255,255,255,.04);
      color: var(--ui);
      font-size: 22px;
      font-weight: 700;
    }
    @media (max-width: 820px) {
      .pad { display: grid; }
    }
    .legend {
      font-size: .9rem; opacity: .8; text-align:center; margin-top: .25rem;
    }
    a { color: var(--accent); }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Pac‑Man: City Icons Edition</h1>
      <div class="subtitle">Munich’s Olympic Tower • Statue of Liberty • Goal: Château Marmont</div>
    </header>

    <div class="hud">
      <div class="score">Score: <span id="score">0</span></div>
      <div class="status" id="status">Ready!</div>
      <button class="btn" id="restart">Restart</button>
    </div>

    <canvas id="game" width="896" height="896" aria-label="Pacman board" role="img"></canvas>

    <div class="pad mobile-controls" aria-hidden="true">
      <div></div>                    <button data-dir="up">▲</button>    <div></div>
      <button data-dir="left">◀</button>  <div></div>                 <button data-dir="right">▶</button>
      <div></div>                    <button data-dir="down">▼</button>  <div></div>
    </div>

    <div class="legend">
      Keyboard: Arrow Keys or WASD • Mobile: Tap controls • Reach the <strong>Château Marmont</strong> icon to win.
      Eat pellets, avoid ghosts. Power pellets stun ghosts for a few seconds.
    </div>
    <footer style="opacity:.6; font-size:.85rem; padding-bottom:.4rem;">
      All imagery is stylized and simplified vector art drawn in‑code (no trademarks). Tweak the map in <code>LEVEL</code> below.
    </footer>
  </div>

<script>
(() => {
  // --- Config ---
  const TILE = 32;                   // pixels per grid cell
  const GRID = 28;                   // 28x28 grid (896px square)
  const SPEED = 2.2;                 // Pac speed (px per frame)
  const GHOST_SPEED = 1.9;
  const FRAMERATE = 1000/60;
  const POWER_TIME = 7_000;
  const CANVAS = document.getElementById("game");
  const CTX = CANVAS.getContext("2d");
  const scoreEl = document.getElementById("score");
  const statusEl = document.getElementById("status");

  // Tiles: 0 empty, 1 wall, 2 pellet, 3 power, 4 goal (Château Marmont)
  // 9 decorative (landmarks, non-blocking)
  // Quick maze: carve paths and pockets for icons.
  const raw = [
    "1111111111111111111111111111",
    "1..2222222221111222222222..1",
    "1.11.111111.1111.111111.11.1",
    "1.11.1....1.2222.1....1.11.1",
    "1.22.1.11.1.1111.1.11.1.22.1",
    "1.11.1.11.1......1.11.1.11.1",
    "1....1.11.11111111.11.1....1",
    "1111.1.11.133..331.11.1.1111",
    "1001.1.11.1  00 1.11.1.10001",
    "1..1.1....1  00 1....1.1..11",
    "1.11.111111  00 111111.11.11",
    "1.11........  00 ........11.1",
    "1.1111111111  00 1111111111.1",
    "1.1111111111  40 1111111111.1",
    "1.1111111111  00 1111111111.1",
    "1.11........  00 ........11.1",
    "1.11.111111  00 111111.11.11",
    "1..1.1....1  00 1....1.1..11",
    "1001.1.11.1  00 1.11.1.10001",
    "1111.1.11.133..331.11.1.1111",
    "1....1.11.11111111.11.1....1",
    "1.11.1.11.1......1.11.1.11.1",
    "1.22.1.11.1.1111.1.11.1.22.1",
    "1.11.1....1.2222.1....1.11.1",
    "1.11.111111.1111.111111.11.1",
    "1..2222222221111222222222..1",
    "1L11111111111111111111111S1",
    "1111111111111111111111111111"
  ];
  // Replace ' ' with 0, '.' with 0 (empty), '0' with 2 (pellet), '3' power, '4' goal
  // 'L' and 'S' will be non-blocking thematic landmarks (Munich Tower / Statue of Liberty)
  const LEVEL = raw.map(row => row.split("").map(c => {
    if (c === "1") return 1;
    if (c === "0") return 2;
    if (c === "3") return 3;
    if (c === "4") return 4;
    if (c === "L" || c === "S") return 9;
    return 0;
  }));

  function inBounds(c,r){ return c>=0 && r>=0 && c<GRID && r<GRID; }

  function tileAt(px, py) {
    const c = Math.floor(px / TILE);
    const r = Math.floor(py / TILE);
    if (!inBounds(c,r)) return 1; // treat offboard as walls
    return LEVEL[r][c];
  }

  function isWall(c, r) {
    if (!inBounds(c,r)) return true;
    return LEVEL[r][c] === 1;
  }

  // --- Entities ---
  const pac = { x: TILE*14 + TILE/2, y: TILE*22 + TILE/2, dir: {x:0,y:0}, next:{x:0,y:0}, mouth:0 };
  const ghosts = [
    { x: TILE*14 + TILE/2, y: TILE*13 + TILE/2, color: getCSS("--ghost1"), dir: {x:0,y:1}, scatter:{c:1,r:1} },
    { x: TILE*13 + TILE/2, y: TILE*13 + TILE/2, color: getCSS("--ghost2"), dir: {x:1,y:0}, scatter:{c:GRID-2,r:1} },
    { x: TILE*15 + TILE/2, y: TILE*13 + TILE/2, color: getCSS("--ghost3"), dir: {x:-1,y:0}, scatter:{c:1,r:GRID-2} },
    { x: TILE*16 + TILE/2, y: TILE*13 + TILE/2, color: getCSS("--ghost4"), dir: {x:0,y:-1}, scatter:{c:GRID-2,r:GRID-2} },
  ];

  let score = 0;
  let powerModeUntil = 0;
  let gameOver = false;
  let youWin = false;

  // --- Helpers ---
  function getCSS(varName){ return getComputedStyle(document.documentElement).getPropertyValue(varName).trim(); }
  function setStatus(msg){ statusEl.textContent = msg; }
  function reset() {
    score = 0; scoreEl.textContent = "0";
    powerModeUntil = 0;
    gameOver = false; youWin = false;
    setStatus("Ready!");
    pac.x = TILE*14 + TILE/2; pac.y = TILE*22 + TILE/2;
    pac.dir = {x:0,y:0}; pac.next = {x:0,y:0};
    pac.mouth = 0;
    // Reset pellets
    for (let r=0;r<GRID;r++){
      for (let c=0;c<GRID;c++){
        const ch = raw[r][c];
        if (ch === "0") LEVEL[r][c] = 2;
        if (ch === "3") LEVEL[r][c] = 3;
        if (ch === "4") LEVEL[r][c] = 4;
        if (ch === "1") LEVEL[r][c] = 1;
        if (ch === " " || ch === "." || ch === "L" || ch === "S") LEVEL[r][c] = ch==="4"?4: (ch==="1"?1: (ch==="3"?3:0));
      }
    }
    // Reset ghosts
    const base = [
      { x: TILE*14 + TILE/2, y: TILE*13 + TILE/2, dir:{x:0,y:1} },
      { x: TILE*13 + TILE/2, y: TILE*13 + TILE/2, dir:{x:1,y:0} },
      { x: TILE*15 + TILE/2, y: TILE*13 + TILE/2, dir:{x:-1,y:0} },
      { x: TILE*16 + TILE/2, y: TILE*13 + TILE/2, dir:{x:0,y:-1} },
    ];
    ghosts.forEach((g,i)=>{
      g.x = base[i].x; g.y = base[i].y; g.dir = base[i].dir;
    });
  }

  // --- Input ---
  const KEYS = {
    "ArrowUp": {x:0,y:-1}, "KeyW": {x:0,y:-1},
    "ArrowDown": {x:0,y:1}, "KeyS": {x:0,y:1},
    "ArrowLeft": {x:-1,y:0}, "KeyA": {x:-1,y:0},
    "ArrowRight": {x:1,y:0}, "KeyD": {x:1,y:0}
  };
  window.addEventListener("keydown", (e) => {
    const d = KEYS[e.code]; if (!d) return;
    pac.next = d;
    if (pac.dir.x===0 && pac.dir.y===0) pac.dir = d; // kickstart
    e.preventDefault();
  }, {passive:false});

  document.querySelectorAll("[data-dir]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const m = btn.dataset.dir;
      const map = {up:{x:0,y:-1}, down:{x:0,y:1}, left:{x:-1,y:0}, right:{x:1,y:0}};
      pac.next = map[m];
      if (pac.dir.x===0 && pac.dir.y===0) pac.dir = map[m];
    });
  });

  document.getElementById("restart").addEventListener("click", reset);

  // --- Movement & Collisions ---
  function canMove(entity, dir) {
    // check ahead using entity center -> project to next tile center safe region
    const nx = entity.x + dir.x * SPEED;
    const ny = entity.y + dir.y * SPEED;
    // Four corners with small padding
    const pad = 10;
    const points = [
      [nx - pad, ny - pad],
      [nx + pad, ny - pad],
      [nx - pad, ny + pad],
      [nx + pad, ny + pad]
    ];
    return points.every(([px,py]) => tileAt(px,py) !== 1);
  }

  function stepPac() {
    // apply next turn if possible (grid-aligned tolerance)
    if (pac.next.x !== pac.dir.x || pac.next.y !== pac.dir.y) {
      // try turn when near tile center
      const tc = Math.floor(pac.x / TILE) * TILE + TILE/2;
      const tr = Math.floor(pac.y / TILE) * TILE + TILE/2;
      if (Math.hypot(pac.x-tc, pac.y-tr) < 6 && canMove({x:tc, y:tr}, pac.next)) {
        pac.x = tc; pac.y = tr;
        pac.dir = pac.next;
      }
    }
    if (canMove(pac, pac.dir)) {
      pac.x += pac.dir.x * SPEED;
      pac.y += pac.dir.y * SPEED;
    }
    // tunnel wrap
    if (pac.x < 0) pac.x = CANVAS.width - 1;
    if (pac.x > CANVAS.width) pac.x = 0;
    // eat mechanics
    const c = Math.floor(pac.x / TILE);
    const r = Math.floor(pac.y / TILE);
    const tile = LEVEL[r][c];
    if (tile === 2) { LEVEL[r][c] = 0; score += 10; scoreEl.textContent = score; }
    if (tile === 3) { LEVEL[r][c] = 0; score += 50; scoreEl.textContent = score; powerModeUntil = performance.now() + POWER_TIME; }
    if (tile === 4) { youWin = true; setStatus("You reached the Château! You win 🎉"); }
  }

  function stepGhost(g) {
    const speed = (performance.now() < powerModeUntil) ? GHOST_SPEED*0.6 : GHOST_SPEED;
    // choose direction occasionally or on collision
    if (!canMove(g, g.dir) || Math.random() < 0.02) {
      const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
      // avoid reversing often
      const opp = {x:-g.dir.x, y:-g.dir.y};
      const choices = dirs.filter(d => d.x!==opp.x || d.y!==opp.y).filter(d => canMove(g,d));
      // mild chase toward pac, else scatter corner
      const target = (performance.now() < powerModeUntil) ? g.scatter : { c: Math.floor(pac.x/TILE), r: Math.floor(pac.y/TILE) };
      let best = g.dir, bestDist = Infinity;
      (choices.length?choices:dirs).forEach(d => {
        if (!canMove(g,d)) return;
        const nx = g.x + d.x*TILE, ny = g.y + d.y*TILE;
        const dc = Math.floor(nx/TILE), dr = Math.floor(ny/TILE);
        const dist = Math.hypot(dc-target.c, dr-target.r);
        if (dist < bestDist) { bestDist = dist; best = d; }
      });
      g.dir = best;
    }
    g.x += g.dir.x * speed;
    g.y += g.dir.y * speed;
    if (g.x < 0) g.x = CANVAS.width - 1;
    if (g.x > CANVAS.width) g.x = 0;
    // collision with pac
    const d = Math.hypot(g.x - pac.x, g.y - pac.y);
    if (d < 18) {
      if (performance.now() < powerModeUntil) {
        // "eat" ghost -> send to pen
        score += 200; scoreEl.textContent = score;
        g.x = TILE*14 + TILE/2; g.y = TILE*13 + TILE/2; g.dir = {x:0,y:1};
        setStatus("Chomp!");
      } else {
        gameOver = true; setStatus("Game Over ☠️  Click Restart");
      }
    }
  }

  // --- Rendering ---
  function draw() {
    // board bg
    CTX.clearRect(0,0,CANVAS.width,CANVAS.height);

    // draw grid/walls
    for (let r=0;r<GRID;r++) {
      for (let c=0;c<GRID;c++) {
        const t = LEVEL[r][c];
        const x = c*TILE, y = r*TILE;
        if (t===1) {
          CTX.fillStyle = getCSS("--wall");
          CTX.fillRect(x,y,TILE,TILE);
          // neon stroke
          CTX.strokeStyle = "rgba(128,255,219,.16)";
          CTX.strokeRect(x+.5,y+.5,TILE-1,TILE-1);
        } else if (t===2) {
          CTX.fillStyle = getCSS("--pellet");
          CTX.beginPath(); CTX.arc(x+TILE/2, y+TILE/2, 3, 0, Math.PI*2); CTX.fill();
        } else if (t===3) {
          CTX.fillStyle = getCSS("--power");
          CTX.beginPath(); CTX.arc(x+TILE/2, y+TILE/2, 6, 0, Math.PI*2); CTX.fill();
        } else if (t===4) {
          drawChateauMarmontIcon(x, y);
        } else if (t===9) {
          // Thematic landmarks (non-blocking)
          // Place rough silhouettes at corners via raw map: 'L' = Olympic Tower, 'S' = Statue of Liberty
          const symbol = raw[r][c]==="L" ? "olympia" : "liberty";
          if (symbol==="olympia") drawOlympicTower(x,y);
          else drawStatueOfLiberty(x,y);
        }
      }
    }

    // draw ghosts
    const frightened = performance.now() < powerModeUntil;
    ghosts.forEach(g => drawGhost(g.x, g.y, frightened ? "#9bd1ff" : g.color));

    // draw pac
    pac.mouth = (pac.mouth + 0.15) % (Math.PI*2);
    const m = Math.abs(Math.sin(pac.mouth))*0.9;
    const ang = Math.atan2(pac.dir.y, pac.dir.x);
    drawPac(pac.x, pac.y, ang, m);

    // overlay: icons labels
    drawLabels();
  }

  function drawPac(x,y, angle, mOpen) {
    CTX.fillStyle = getCSS("--pacman");
    const r = 13;
    const start = angle - mOpen*0.6;
    const end = angle + mOpen*0.6;
    CTX.beginPath();
    CTX.moveTo(x,y);
    CTX.arc(x,y,r,start,end);
    CTX.closePath();
    CTX.fill();
    // eye
    CTX.fillStyle = "#000";
    CTX.beginPath();
    CTX.arc(x + Math.cos(angle - Math.PI/2)*6, y + Math.sin(angle - Math.PI/2)*6, 2, 0, Math.PI*2);
    CTX.fill();
  }

  function drawGhost(x,y,color) {
    CTX.fillStyle = color;
    CTX.beginPath();
    const r = 12;
    CTX.arc(x, y, r, Math.PI, 0);
    CTX.lineTo(x+r, y+r);
    for (let i=0;i<6;i++){
      const dx = x + r - i*(r*2/5);
      const dy = y + r + (i%2?4:0);
      CTX.lineTo(dx, dy);
    }
    CTX.closePath();
    CTX.fill();
    // eyes
    CTX.fillStyle = "#fff";
    CTX.beginPath(); CTX.arc(x-5, y, 4, 0, Math.PI*2); CTX.arc(x+5, y, 4, 0, Math.PI*2); CTX.fill();
    CTX.fillStyle = "#001030";
    CTX.beginPath(); CTX.arc(x-5, y, 2, 0, Math.PI*2); CTX.arc(x+5, y, 2, 0, Math.PI*2); CTX.fill();
  }

  function drawOlympicTower(x,y) {
    // Simple Munich Olympic Tower silhouette (antenna + disk + tower)
    CTX.save();
    CTX.translate(x+TILE/2, y+TILE/2);
    CTX.scale(1.0,1.0);
    CTX.fillStyle = "#cdd6f4";
    CTX.strokeStyle = "rgba(205,214,244,.35)";
    // tower stem
    CTX.fillRect(-3,-14,6,24);
    // observation disk
    CTX.beginPath();
    CTX.ellipse(0,-6,12,5,0,0,Math.PI*2);
    CTX.fill();
    // antenna
    CTX.fillRect(-1,-24,2,10);
    CTX.beginPath();
    CTX.moveTo(0,-26); CTX.lineTo(3,-22); CTX.lineTo(-3,-22); CTX.closePath();
    CTX.fill();
    CTX.restore();
  }

  function drawStatueOfLiberty(x,y) {
    // Minimalist Statue of Liberty: pedestal + robe + torch
    CTX.save();
    CTX.translate(x+TILE/2, y+TILE/2);
    CTX.fillStyle = "#b7ffe1";
    // pedestal
    CTX.fillRect(-8,6,16,4);
    // robe
    CTX.beginPath();
    CTX.moveTo(-6,6); CTX.lineTo(0,-10); CTX.lineTo(6,6); CTX.closePath(); CTX.fill();
    // arm + torch
    CTX.fillRect(1,-12,2,6);
    CTX.fillStyle = "#ffd166";
    CTX.beginPath(); CTX.arc(2,-14,3,0,Math.PI*2); CTX.fill();
    CTX.restore();
  }

  function drawChateauMarmontIcon(x,y) {
    // Simplified Château Marmont facade silhouette
    CTX.save();
    CTX.translate(x, y);
    const w = TILE, h = TILE;
    CTX.fillStyle = "rgba(255,255,255,.9)";
    // base block
    CTX.fillRect(4, 12, w-8, h-16);
    // roof
    CTX.beginPath();
    CTX.moveTo(6,12); CTX.lineTo(w/2,4); CTX.lineTo(w-6,12); CTX.closePath(); CTX.fill();
    // tiny windows
    CTX.fillStyle = "#3b3b3b";
    for (let i=0;i<3;i++) for (let j=0;j<2;j++) {
      CTX.fillRect(8+i*8, 14+j*8, 4, 4);
    }
    CTX.restore();
  }

  function drawLabels() {
    CTX.save();
    CTX.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    CTX.fillStyle = "rgba(255,255,255,.75)";
    // Annotate corners roughly where icons are
    // Top-left (Olympic Tower)
    CTX.fillText("Olympiaturm (Munich)", TILE*1 + 4, TILE*26 + 18);
    // Bottom-right (Statue of Liberty)
    CTX.fillText("Statue of Liberty", TILE*26 - 128, TILE*26 + 18);
    // Goal caption
    CTX.fillStyle = "rgba(255,255,255,.85)";
    CTX.fillText("Goal → Château Marmont", TILE*13 - 70, TILE*14 - 10);
    CTX.restore();
  }

  // --- Loop ---
  let last = 0;
  function loop(t){
    if (!last) last = t;
    const dt = t - last;
    if (dt >= FRAMERATE) {
      if (!gameOver && !youWin) {
        stepPac();
        ghosts.forEach(stepGhost);
        setStatus(performance.now() < powerModeUntil ? "Power Mode! 👻" : "Run!");
      }
      draw();
      last = t;
    }
    requestAnimationFrame(loop);
  }
  reset();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
